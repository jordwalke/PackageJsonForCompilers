Here's a suggestion that sets up the build system to work well with our other `ocamlopt` projects, and interop well with the ocaml ecosystem. Build systems do not have to generate this structure, they merely need the features required to work within it.

General layout of build tree.
- Allows multiple versions of packages to coexist (it's important).
- Builds out of source, installs out of source.
  - That enables symlinking of packages (important).
- Plays nice with ocamlfind.
- Allows cleaning up of build artifacts trivially, without 


In general, we have a top level package, with dependencies inside of `node_modules`, and two directories `_build` and `_install` which each mirror the entire directory.
    
    Project Directory
    ========================

    /path/to/MyApp/
     │                       Findlib Installations 
     ├── _install/         ----------------------------------------
     │   └── node_modules/    _install dir mirrors project directory,
     │       └── ...          contains findlib installations for everything.
     │
     ├── _build/             Build Artifacts
     │   ├── src/            ----------------------------------------
     │   │   └── ...         _build dir mirrors entire tree.
     │   └── node_modules/   Contains build artifacts for everything.
     │       └── ...
     │
     ├── package.json        Original Source Files                              
     ├── src/                ----------------------------------------           
     │   ├── files.ml        Your typical source directory with node_modules    
     │   └── ...             containing all dependencies potentially symlinked. 
     │
     └── node_modules/
         └── ...

Expanding out a bit, we see that inside of the `_install`, each package resides
in its mirrored location. Each package has its *own* `findlib` root, with its
own `bin`/`lib` etc. This is very important as it allows multiple versions of a
single package to exist simultaneously.


    Project Directory
    ========================

    /path/to/MyApp/
     │                           Findlib Installations 
     ├─ _install/              ----------------------------------------
     │  ├─ bin/               ╮  First, you have the findlib installation
     │  ├─ lib/               ╯  for the top level package
     │  └─ node_modules/   
     │     ├─ CommonUtil      ╮                    
     │     │  ├─ bin/         ┊  Then transitive dependencies' findlib installations.
     │     │  └─ lib/         ┊
     │     └─ ...             ╯                    
     │     
     │                           Build Artifacts
     ├─ _build/                  ----------------------------------------
     │  │                     ╮  Autogenerated findlib.conf describing the location
     │  ├─ findlib.conf       ┊  of each transitive dependency of the root package. 
     │  │                     ┊  (pointing to locations in _install)
     │  ├─ myApp.exe                                                        
     │  ├─ src/               ┊  Top level package's artifacts at locations 
     │  │  └─ ...             ┊   mirroringtheir original locations         
     │  │                     ╯                                             
     │  └─ node_modules/
     │     ├─ CommonUtil      ╮  
     │     │  ├─ findlib.conf ┊  Artifacts for all node_modules dependencies.
     │     │  └─ src/         ┊ 
     │     │      └─ ...      ┊
     │     └─ ...             ╯
     │
     │                           Original Source Files
     │                           ----------------------------------------
     ├─ package.json             Your typical source directory with node_modules
     ├─ src/                     containing all dependencies potentially symlinked.
     │  ├─ files.ml
     │  └─ ...
     └─ node_modules/
        ├─ ...              
        └─ CommonUtil/ --> /symlink/to/CommonUtil          
                                                                           


Expanding out even further:

    Project Directory
    ========================

    /path/to/MyApp/
     │                                  Findlib Installations                   
     ├─ _install/                     ----------------------------------------
     │   ├─ bin/
     │   │  └─ myApp.exe
     │   ├─ lib/
     │   │  └─ MyApp/                ╮  Because each library has its own
     │   │     ├─ META               ┊  findlib root it has to place another
     │   │     ├─ myApp.cmi          ┊  directory inside of `lib` matching its
     │   │     └─ myApp.cmo          ╯  package name. META file goes in there.
     │   │
     │   └─ node_modules/
     │      ├─ YourProject
     │      │  ├─ bin/
     │      │  └─ lib/
     │      │     └─ YourProject/
     │      │        ├─ META
     │      │        ├─ yours.cmo
     │      │        └─ util.cmo/
     │      └─ CommonUtil
     │         ├─ bin/
     │         └─ lib/
     │            └─ CommonUtil/
     │               ├─ META
     │               ├─ common.cmo
     │               └─ util.cmo/
     │                                  Build Artifacts
     ├─ _build/                         ----------------------------------------
     │  ├─ findlib.conf
     │  ├─ myApp.exe
     │  ├─ src/                      ╮                                                   
     │  │  ├─ myApp.cmo              ┊  In the _build directory, every artifacts
     │  │  ├─ myApp.cmi              ┊  mirrors locations of corresponding source
     │  │  └─ util.cmo               ╯  file - if any.
     │  │
     │  └─ node_modules/
     │     ├─ YourProject
     │     │  ├─ findlib.conf
     │     │  ├─ package.json
     │     │  └─ src/
     │     │     ├─ yours.cmo
     │     │     └─ util.cmo
     │     │
     │     └─ CommonUtil
     │        ├─ findlib.conf
     │        └─ src/
     │           ├─ common.cmo
     │           └─ util.cmo
     │
     │                                  Original Source Files
     │                                  ----------------------------------------
     ├─ package.json
     ├─ src/
     │  ├─ myApp.mli
     │  ├─ myApp.ml
     │  └─ util.ml
     │
     └─ node_modules/
        ├─ YourProject/
        │  ├─ package.json
        │  └─ src/
        │     ├─ yours.ml
        │     └─ util.ml
        │                         
        └─ CommonUtil/ --> /symlink/to/CommonUtil 
                              │             │
                              ╰┄┄┄┄┄┄┄┄┄┄┄┄┄╯
                            symlinks must be supported.        
                            even if they are only simulated via
                            some kind of .links file.                   


## BuildTimeOnlyDependencies

As discussed in [this
issue](https://github.com/facebook/reason/issues/816#issue-183870566) a
distinction between build time dependencies and runtime dependencies is helpful
in relaxing the flattening requirement of package version. In doing so, it will
be common for multiple versions to exist simultaneously and this organization
above allows for that. This is useful even when multiple versions are not
allowed to be linked into one final executable.

## Cross Compiling

Because of the need to distinguish between `buildTimeOnlyDependency` and
`runTime` dependencies we wanted to support resolving to, and building multiple
*versions* of one package, in order to minimize conflicts, and mitigate the
challenge of flattening package version.

But if we allow installing a package with a target architecture that is
different than the host, then `buildTimeOnlyDependency` doesn't just create an
opportunity to make flattening easier, which had us building multiple *versions* of
a package - it also means we *need* to build a package multiple times, once for
each architecture that is needed. In that case, we could be building two different
versions, each with the architecture they need - but we could also need to build
*one* version, multiple times, for different architectures.
`buildTimeOnlyDependencies` imply that we need to compile those dependencies
for the host architecture, and other dependencies are implicitly runtime
dependencies and require building for the target architecture.

We haven't discussed how we allow users to specify the architecture at install time.

We extend the build directories above to allow for this, but suffixing `_install`
and `_build` with the architecture. By default, it's assumed
`_install`/`_build` refer to the host architecture.

    Project Directory
    ========================

    /path/to/MyApp/
     │                       Findlib Installations 
     ├── _install/         ----------------------------------------
     │   └── node_modules/    _install dir mirrors project directory,
     │       └── ...          contains findlib installations for everything.
     ├── _install_arm/
     │   └── node_modules/
     │       └── ...
     │
     ├── _build_arm/         Build Artifacts
     │   ├── src/            ----------------------------------------
     │   │   └── ...         _build dir mirrors entire tree.
     │   └── node_modules/   Contains build artifacts for everything.
     │       └── ...
     │
     ├── package.json        Original Source Files                              
     ├── src/                ----------------------------------------           
     │   ├── files.ml        Your typical source directory with node_modules    
     │   └── ...             containing all dependencies potentially symlinked. 
     │
     └── node_modules/
         └── ...


## This Is Intended For *Any* Build System.

Most of this is not specific to any particular build system, and build systems don't need to know about this *exact* directory structure. When a package is built (via its `postinstall`), `dependencyEnv` sets up environment variables that handles all the logic of figuring out where things should go.

## Doing It Right

To properly create a package:

1. Activate the build utilities via `dependency-env`:
  - Add [dependency-env](https://github.com/reasonml/dependency-env) to your package's `dependencies`.
  - In your `postinstall`, prefix your build command with `eval $(dependencyEnv)
    &&`, in order activate the utilities to help you perform a proper build. For example: `eval $(dependencyEnv) && make`.

2. Enjoy some benefits of `dependencyEnv`.
`dependencyEnv` sets the `OCAMLFIND_CONF` environment variable to point to an *automatically* generated `findlib.conf`. This makes it so popular build tooling (`ocamlbuild/rebuild`, `ocamlfind`) can "see" your built `npm` dependencies. `dependencyEnv` also sets up a bunch of other helpful environment variables that your build scripts can use.

3. Respect the `cur__target_dir` environment variable in your build scripts.
Your build system should try to only generate artifacts inside of `cur__target_dir`. This makes sure your package build works with symlinks, and multiple simultaneous versions of your package.

4. Respect the `cur__install` environment variable in your build scripts:
So far your package build plays nice, and can build correctly because it can "see" its dependencies at build time via `findlib.conf`. That's good but it doesn't mean *your* package's artifacts will be visible to *other* packages that depend on *you*! To make your package available and visible to your dependers, your build system should generate a `META` file, and *install* it (along with a subset of the artifacts) into `cur__install` (`ocamlfind install -destdir $cur__install $cur__name META`).

|Environment Variable| Meaning                                                            | Equivalent To                        |
|--------------------|--------------------------------------------------------------------|--------------------------------------|
| `cur__name`  | Normalized name of package name (converts hyphens to underscores)        |                                      |
| `cur__target_dir`  | Where build artifacts should go for the currently building package  | Cargo's `CARGO_TARGET_DIR` (loosely) |
| `cur__install`     | Install root for currently building package. Contains lib/bin/etc   | OPAM's `prefix` var, but is a dedicated install directory just for this package |


## Environment Variables

When `your-package` is being built, `cur__target_dir` and `cur__install` are
set to the artifact and install destinations for `your-package`. This helps
avoid cluttering up your source files with artifacts, and keeps it symlink
friendly / caching friendly.

#### More Variables Visible To Your Package Build Scripts

|Environment Var | Meaning                                                                    | Equivalent To             |
|----------------|----------------------------------------------------------------------------|---------------------------|
| `FINDLIB_CONF` | Path to precomputed findlib.conf file, exposing `cur`'s dependencies       |                           |
| `version`      | Version of the current dependencyEnv package                               | Opam's `opam-version`     |
| `sandbox`      | Path to top level package being installed - the thing you git cloned       |                           |
| `_install_tree`| Path to install tree, which contains all prefixes, for all packages        |                           |
| `_build_tree`  | Path to build tree, which contains all build directories, for all packages |                           |
| `cur__lib`     | Path to `lib` directory in `cur__install`                                  | Opam's `lib`                |
| `cur__bin`     | Path to `bin` directory in `cur__install`                                  | Opam's `bin`                |
| `cur__sbin`    | Path to `sbin` directory in `cur__install`                                 | Opam's `sbin`               |
| `cur__doc`     | Path to `doc` directory in `cur__install`                                  | Opam's `doc`                |
| `cur__stublibs`| Path to `stublibs` directory in `cur__install`                             | Opam's `stublibs`           |
| `cur__toplevel`| Path to `toplevel` directory in `cur__install`                             | Opam's `toplevel`           |
| `cur__man`     | Path to `man` directory in `cur__install`                                  | Opam's `man`                |
| `cur__share`   | Path to `share` directory in `cur__install`                                | Opam's `share`              |
| `cur__etc`     | Path to `etc` directory in `cur__install`                                  | Opam's `etc`                |

###### Opam Variables That Don't Make Sense To Recreate

|Environment Variable|
|--------------------|
| `root`             |

#### Variables Automatically Published by *Your* Dependencies

Sometimes, your dependencies want to communicate values/paths to you. They can do this easily in their `package.json`'s `exportedEnvVars` field, which causes those values to be visible to your build scripts (as long as you do `eval $(dependencyEnv)`).

Some environment variables are *automatically* published without them even having to specify them. If `my-package` has a *direct* dependency on `my-dependency`, then whenever `my-package` invokes `eval $(dependencyEnv)`, it will see the following environment variables changed:


|Environment Variable     | Your Package's Dependers See This Value As     | Equivalent To                           | Implemented |
|-------------------------|------------------------------------------------|-----------------------------------------|-------------|
|`PATH`                   | Augmented with `my_dependency__bin`            |                                         | No          |
|`MAN_PATH`               | Augumented with `my_dependency__man`           | OPAM's `PKG:name` but not transitive    | No          |
|`my_dependency__name`    | Normalized name of the `my-dependency` (`my_dependency`) | OPAM's `PKG:name` but not transitive    | No          |
|`my_dependency__version` | Version of the `my-dependency`                 | OPAM's `PKG:version` but not transitive | No          |
|`my_dependency__depends` | Resolved direct dependencies of `my-dependency`| OPAM's `PKG:depends`                    |             |
|`my_dependency__bin`     | Binary install directory for `my-dependency`   | OPAM's `PKG:bin` but not transitive     | No          |
|`my_dependency__sbin`    | System install Binary directory for `my-dependency`| OPAM's `PKG:sbin` but not transitive| No          |
|`my_dependency__lib`     | Library install directory for `my-dependency`  | OPAM's `PKG:lib` but not transitive     | No          |
|`my_dependency__man`     | Man install directory for `my-dependency`      | OPAM's `PKG:man` but not transitive     | No          |
|`my_dependency__doc`     | Docs install directory for `my-dependency`     | OPAM's `PKG:doc` but not transitive     | No          |
|`my_dependency__share`   | Share install directory for `my-dependency`    | OPAM's `PKG:share` but not transitive   | No          |
|`my_dependency__etc`     | Etc install directory for `my-dependency`      | OPAM's `PKG:etc` but not transitive     | No          |


Many of these variables have OPAM equivalents, with the exception that they are only published by *immediate* dependencies. The reason is that unlike OPAM, we support multiple versions per package in the transitive dependency graph - so some of these variables would no longer be well-defined if we allowed them to be published by transitive dependencies.

The following OPAM variables will be more difficult to implement as environment variables, but we should support them anyways.

|OPAM var        |                                                 | Difficult Because                                                                 | Implemented |
|----------------|-------------------------------------------------|-----------------------------------------------------------------------------------|-------------|
|`PKG:installed` | Whether the package is installed                | Need to scan "optionalDeps" and set false if missing                              | No          |
|`PKG:enable`    | "enable" or "disable" depending on if installed | "                                                                                 | No          |
|`PKG:build`     | Where `my-dependency` ended up being built      | We *tell* packages where to build. They might not respect that - how do we know?  | No          |


Others not yet implemented: (`PKG:hash`, `user`, `group`, `make`, `os`,
`ocaml-version`, `opam-version` `compiler`, `preinstalled`, `switch`, `jobs`,
`ocaml-native`, `ocaml-native-tool`, `ocaml-native-dynli`, `arch` )


### Not Shown In This Spec

- Opinionated build system conventions such as module aliases/namespaces.
- How we would implement the system that walks the dependency graph, asking
  each package to build itself into the correct locations.
- How we know which architecture to specify when building a package (based on
  `buildTimeOnlyDependency`, the host architecture, and "target" architecture).
- How we know how many times to build a package - how many architectures.

